import { PackageCmd, Callout } from '@theguild/components'

# Defer and Stream

Stream and defer are directives that allow you to improve latency for clients by sending data the most important data as soon as it's ready.

As applications grow, the GraphQL operation documents can get bigger..
The server will only send the response back once all the data requested in the query is ready.
However, not all requested data is of equal importance, and the client may not need all of the data at once.
To remedy this, GraphQL specification working group is working on [introducing new `@defer` and `@stream` directives](https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md)
which allows applications to request a subset of data which is critical and get the rest of the data in subsequent responses from the server.
This [proposal](https://github.com/graphql/graphql-spec/pull/742) is in [Stage 2](https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-2-draft),
meaning GraphQL libraries can start implementing this as experimental feature to provide feedback to the working group.

<Callout>
  Stream and Defer are **experimental** features and not yet stable. The
  implementation can and will change. Furthermore, there is no yet a stable
  specification for the incremental delivery protocol.
</Callout>

## Installation

Enabling support for the `@defer` and `@stream` directive requires installing a plugin.

<PackageCmd packages={['@graphql-yoga/plugin-defer-stream']} />

## Quick Start

The following schema shows a schema whose field resolvers are slow

```ts filename="Slow Schema" {29,33, 37}
import { createYoga, createSchema } from 'graphql-yoga'
import { createServer } from 'node:http'
import { useDeferStream } from '@graphql-yoga/plugin-defer-stream'

const typeDefs = /* GraphQL */ `
  type Query {
    alphabet: [String!]!
    """
    A field that resolves fast.
    """
    fastField: String!

    """
    A field that resolves slowly.
    Maybe you want to @defer this field ;)
    """
    slowField(waitFor: Int! = 5000): String
  }
`

const wait = (time: number) =>
  new Promise((resolve) => setTimeout(resolve, time))

const resolvers = {
  Query: {
    async *alphabet() {
      for (const character of ['a', 'b', 'c', 'd', 'e', 'f', 'g']) {
        yield character
        await wait(1000)
      }
    },
    fastField: async () => {
      await wait(100)
      return 'I am speed'
    },
    slowField: async (_, { waitFor }) => {
      await wait(waitFor)
      return 'I am slow'
    }
  }
}

const yoga = createYoga({
  schema: createSchema({
    typeDefs,
    resolvers
  }),
  plugins: [useDeferStream()]
})

const server = createServer(yoga)

server.listen(4000, () => {
  console.info('Server is running on http://localhost:4000/graphql')
})
```

Start the server

### Using Defer

Visit http://localhost:4000/graphql and paste the following operation into the left panel.

```graphql filename="GraphQL Operation using @defer" {2}
query SlowAndFastFieldWithDefer {
  ... on Query @defer {
    slowField
  }
  fastField
}
```

Then press the Play (Execute Query) button.

Alternatively, you can also send the defer operation via curl.

```sh filename="curl command for executing @defer operation"
curl -g -X POST \
  -H "accept:multipart/mixed" \
  -H "content-type: application/json" \
  -d '{"query":"query SlowAndFastFieldWithDefer { ... on Query @defer { slowField } fastField }"}' \
  http://localhost:4000/graphql
```

### Using Stream

Visit http://localhost:4000/graphql and paste the following operation into the left panel.

```graphql filename="GraphQL Operation using @stream" {2}
query StreamAlphabet {
  alphabet @stream
}
```

Then press the Play (Execute Query) button.

Alternatively, you can also send the stream operation via curl.

```sh
curl -g -X POST \
  -H "accept:multipart/mixed" \
  -H "content-type: application/json" \
  -d '{"query":"query StreamAlphabet { alphabet @stream }"}' \
  http://localhost:4000/graphql
```
