---
id: file-uploads
title: Enable File Uploads in GraphQL Yoga
sidebar_label: File Uploads
---

GraphQL Yoga supports [GraphQL Multipart Request Specification](https://github.com/jaydenseric/graphql-multipart-request-spec) which basically allows you to upload files via HTTP and consume the binary data inside GraphQL Resolvers.

In GraphQL Yoga, you consume uploaded files or blobs as W3 standard [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects you might be familiar from the browser's API.

[Check out MDN documentation to learn more about `File` objects](https://developer.mozilla.org/en-US/docs/Web/API/File)

You can use any kind of client supports GraphQL Upload specification.
[Check out here to find GraphQL Client solutions](https://github.com/jaydenseric/graphql-multipart-request-spec#client)

## Example

`file-upload-example.ts`

```ts
import { createGraphQLServer } from 'graphql-yoga'

// Provide your schema
const server = createGraphQLServer({
  typeDefs: /* GraphQL */ `
    type Query {
      greetings: String!
    }
    type Mutation {
      readTextFile(file: Upload!): String!
    }
  `,
  resolvers: {
    Query: {
      greetings: () => 'Hello World!',
    },
    Mutation: {
      readTextFile: async (_, { file }: { file: File }) => {
        const textContent = await file.text()
        return textContent
      },
    },
  },
})
// Start the server and explore http://localhost:4000/graphql
server.start()
```

### Test your GraphQL Server with `cURL`

```sh
curl localhost:4000/graphql \
  -F operations='{ "query": "mutation ($file: File!) { readTextFile(file: $file) }", "variables": { "file": null } }' \
  -F map='{ "0": ["variables.file"] }' \
  -F 0=@mytext.txt
```

### Want to use `Upload` as scalar type name for File Uploads?

Usually `graphql-upload` compliant servers use `Upload` name but GraphQL Yoga has two different scalar types `File` for uploaded files with a mimetype and/or name and `Blob` for unnamed binary data.

You can keep the same behavior by adding `scalar Upload` and add `GraphQLFile` as a resolver for that scalar like below;

```ts
{
    typeDefs: [...otherTypeDefs, `scalar Upload`],
    resolvers: {
      Upload: GraphQLFile,
      ...otherResolvers,
    },
}
```
