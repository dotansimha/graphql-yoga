diff --git a/node_modules/nextra/context.js b/node_modules/nextra/context.js
deleted file mode 100644
index 77e9dd1..0000000
--- a/node_modules/nextra/context.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/context')
diff --git a/node_modules/nextra/data.js b/node_modules/nextra/data.js
deleted file mode 100755
index 9016f08..0000000
--- a/node_modules/nextra/data.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/ssg')
diff --git a/node_modules/nextra/dist/compile.mjs b/node_modules/nextra/dist/compile.mjs
new file mode 100644
index 0000000..b688c27
--- /dev/null
+++ b/node_modules/nextra/dist/compile.mjs
@@ -0,0 +1,552 @@
+var __defProp = Object.defineProperty;
+var __defProps = Object.defineProperties;
+var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
+var __getOwnPropSymbols = Object.getOwnPropertySymbols;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __propIsEnum = Object.prototype.propertyIsEnumerable;
+var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __spreadValues = (a, b) => {
+  for (var prop in b || (b = {}))
+    if (__hasOwnProp.call(b, prop))
+      __defNormalProp(a, prop, b[prop]);
+  if (__getOwnPropSymbols)
+    for (var prop of __getOwnPropSymbols(b)) {
+      if (__propIsEnum.call(b, prop))
+        __defNormalProp(a, prop, b[prop]);
+    }
+  return a;
+};
+var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
+var __async = (__this, __arguments, generator) => {
+  return new Promise((resolve, reject) => {
+    var fulfilled = (value) => {
+      try {
+        step(generator.next(value));
+      } catch (e) {
+        reject(e);
+      }
+    };
+    var rejected = (value) => {
+      try {
+        step(generator.throw(value));
+      } catch (e) {
+        reject(e);
+      }
+    };
+    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
+    step((generator = generator.apply(__this, __arguments)).next());
+  });
+};
+
+// src/compile.ts
+import { createProcessor } from "@mdx-js/mdx";
+import remarkGfm from "remark-gfm";
+import rehypePrettyCode from "rehype-pretty-code";
+import { rehypeMdxTitle } from "rehype-mdx-title";
+
+// src/mdx-plugins/static-image.js
+var relative = /^\.{1,2}\//;
+function visit(node, type2, handler) {
+  if (node.type === type2) {
+    handler(node);
+  }
+  if (node.children) {
+    node.children.forEach((n) => visit(n, type2, handler));
+  }
+}
+function ASTNodeImport(name2, from) {
+  return {
+    type: "mdxjsEsm",
+    value: `import ${name2} from "${from}"`,
+    data: {
+      estree: {
+        type: "Program",
+        body: [
+          {
+            type: "ImportDeclaration",
+            specifiers: [
+              {
+                type: "ImportDefaultSpecifier",
+                local: { type: "Identifier", name: name2 }
+              }
+            ],
+            source: {
+              type: "Literal",
+              value: from,
+              raw: `"${from}"`
+            }
+          }
+        ],
+        sourceType: "module"
+      }
+    }
+  };
+}
+function remarkStaticImage() {
+  return (tree, _file, done) => {
+    const importsToInject = [];
+    visit(tree, "image", visitor);
+    tree.children.unshift(...importsToInject);
+    tree.children.unshift(ASTNodeImport("$NextImageNextra", "next/image"));
+    done();
+    function visitor(node) {
+      const url = node.url;
+      if (url && relative.test(url)) {
+        const tempVariableName = `$nextraImage${importsToInject.length}`;
+        Object.assign(node, {
+          type: "mdxJsxFlowElement",
+          name: "$NextImageNextra",
+          attributes: [
+            {
+              type: "mdxJsxAttribute",
+              name: "alt",
+              value: node.alt || ""
+            },
+            {
+              type: "mdxJsxAttribute",
+              name: "placeholder",
+              value: "blur"
+            },
+            {
+              type: "mdxJsxAttribute",
+              name: "src",
+              value: {
+                type: "mdxJsxAttributeValueExpression",
+                value: tempVariableName,
+                data: {
+                  estree: {
+                    type: "Program",
+                    body: [
+                      {
+                        type: "ExpressionStatement",
+                        expression: {
+                          type: "Identifier",
+                          name: tempVariableName
+                        }
+                      }
+                    ],
+                    sourceType: "module"
+                  }
+                }
+              }
+            }
+          ],
+          children: []
+        });
+        importsToInject.push(ASTNodeImport(tempVariableName, url));
+      }
+    }
+  };
+}
+
+// src/mdx-plugins/remark.ts
+function visit2(node, tester, handler) {
+  if (tester(node)) {
+    handler(node);
+  }
+  if (node.children) {
+    node.children.forEach((n) => visit2(n, tester, handler));
+  }
+}
+function getFlattenedValue(node) {
+  return node.children.map((child) => "children" in child ? getFlattenedValue(child) : "value" in child ? child.value : "").join("");
+}
+function remarkHeadings() {
+  const data = this.data();
+  return (tree, _file, done) => {
+    visit2(tree, (node) => {
+      return node.type === "heading" || node.name === "summary" || node.name === "details";
+    }, (node) => {
+      if (node.type === "heading") {
+        const heading = __spreadProps(__spreadValues({}, node), {
+          value: getFlattenedValue(node)
+        });
+        data.headingMeta.headings.push(heading);
+      } else if (node.name === "summary" || node.name === "details") {
+        if (node.data) {
+          delete node.data._mdxExplicitJsx;
+        }
+      }
+    });
+    done();
+  };
+}
+
+// src/mdx-plugins/structurize.js
+import Slugger from "github-slugger";
+function cleanup(content) {
+  return content.trim().split("\n").map((line) => line.trim()).join("\n");
+}
+var structurize_default = (structurizedData, options) => {
+  if (typeof options === "boolean")
+    options = {};
+  options = Object.assign({ codeblocks: true }, options);
+  const slugger = new Slugger();
+  let activeSlug = "";
+  let skip = false;
+  let content = "";
+  return function stripMarkdown() {
+    return (node) => {
+      walk(node);
+      structurizedData[activeSlug] = cleanup(content);
+      return node;
+    };
+    function walk(node) {
+      let result = "";
+      const type2 = node.type;
+      if (type2 === "heading")
+        skip = true;
+      if (["code", "table", "blockquote", "list", "mdxJsxFlowElement"].includes(type2)) {
+        result += "\n";
+        if (!skip)
+          content += "\n";
+      }
+      if ("children" in node) {
+        for (let i = 0; i < node.children.length; i++) {
+          result += walk(node.children[i]);
+        }
+      } else if ([
+        options.codeblocks ? "code" : "",
+        "text",
+        "inlineCode",
+        "tableCell"
+      ].includes(type2)) {
+        result += node.value;
+        if (!skip)
+          content += node.value;
+      }
+      if ([
+        "code",
+        "table",
+        "blockquote",
+        "list",
+        "listItem",
+        "break",
+        "mdxJsxFlowElement"
+      ].includes(type2)) {
+        result += "\n";
+        if (!skip)
+          content += "\n";
+      }
+      if (["tableCell"].includes(type2)) {
+        result += "	";
+        if (!skip)
+          content += "	";
+      }
+      if (type2 === "heading")
+        skip = false;
+      if (type2 === "heading" && node.depth > 1) {
+        structurizedData[activeSlug] = cleanup(content);
+        content = "";
+        activeSlug = slugger.slug(result) + "#" + result;
+      }
+      return result;
+    }
+  };
+};
+
+// src/mdx-plugins/rehype-handler.js
+import Slugger2 from "github-slugger";
+function visit3(node, tagNames, handler) {
+  if (tagNames.includes(node.tagName)) {
+    handler(node);
+    return;
+  }
+  if (node.children) {
+    node.children.forEach((n) => visit3(n, tagNames, handler));
+  }
+}
+function parseMeta() {
+  return (tree) => {
+    visit3(tree, ["pre"], (node) => {
+      var _a, _b, _c;
+      if (Array.isArray(node.children) && node.children.length === 1 && node.children[0].tagName === "code" && typeof node.children[0].properties === "object") {
+        const meta = (_b = (_a = node.children[0].data) == null ? void 0 : _a.meta) != null ? _b : node.children[0].properties.metastring;
+        if (meta) {
+          const filename = (_c = meta.match(/filename="([^"]+)"/)) == null ? void 0 : _c[1];
+          if (filename) {
+            node.__nextra_filename__ = filename;
+          }
+        }
+      }
+    });
+  };
+}
+function attachMeta() {
+  return (tree) => {
+    const slugger = new Slugger2();
+    visit3(tree, ["div", "h2", "h3", "h4", "h5", "h6"], (node) => {
+      if (node.tagName === "div") {
+        if (!("data-rehype-pretty-code-fragment" in node.properties))
+          return;
+        node.properties["data-nextra-code"] = "";
+        if ("__nextra_filename__" in node) {
+          node.properties["data-filename"] = node.__nextra_filename__;
+        }
+      } else {
+        node.properties.id = node.properties.id || slugger.slug(getFlattenedValue(node));
+      }
+    });
+  };
+}
+
+// src/theme.json
+var name = "css-variables";
+var type = "light";
+var colors = {
+  "editor.foreground": "#000001",
+  "editor.background": "#000002"
+};
+var tokenColors = [
+  {
+    settings: {
+      foreground: "#000001"
+    }
+  },
+  {
+    scope: [
+      "markup.deleted",
+      "meta.diff.header.from-file",
+      "punctuation.definition.deleted"
+    ],
+    settings: {
+      foreground: "#ef6270"
+    }
+  },
+  {
+    scope: [
+      "markup.inserted",
+      "meta.diff.header.to-file",
+      "punctuation.definition.inserted"
+    ],
+    settings: {
+      foreground: "#4bb74a"
+    }
+  },
+  {
+    scope: [
+      "keyword.operator.accessor",
+      "meta.group.braces.round.function.arguments",
+      "meta.template.expression",
+      "markup.fenced_code meta.embedded.block"
+    ],
+    settings: {
+      foreground: "#000001"
+    }
+  },
+  {
+    scope: "emphasis",
+    settings: {
+      fontStyle: "italic"
+    }
+  },
+  {
+    scope: ["strong", "markup.heading.markdown", "markup.bold.markdown"],
+    settings: {
+      fontStyle: "bold"
+    }
+  },
+  {
+    scope: ["markup.italic.markdown"],
+    settings: {
+      fontStyle: "italic"
+    }
+  },
+  {
+    scope: "meta.link.inline.markdown",
+    settings: {
+      fontStyle: "underline",
+      foreground: "#000004"
+    }
+  },
+  {
+    scope: ["string", "markup.fenced_code", "markup.inline"],
+    settings: {
+      foreground: "#000005"
+    }
+  },
+  {
+    scope: ["comment", "string.quoted.docstring.multi"],
+    settings: {
+      foreground: "#000006"
+    }
+  },
+  {
+    scope: [
+      "constant.numeric",
+      "constant.language",
+      "constant.other.placeholder",
+      "constant.character.format.placeholder",
+      "variable.language.this",
+      "variable.other.object",
+      "variable.other.class",
+      "variable.other.constant",
+      "meta.property-name",
+      "meta.property-value",
+      "support"
+    ],
+    settings: {
+      foreground: "#000004"
+    }
+  },
+  {
+    scope: [
+      "keyword",
+      "storage.modifier",
+      "storage.type",
+      "storage.control.clojure",
+      "entity.name.function.clojure",
+      "entity.name.tag.yaml",
+      "support.function.node",
+      "support.type.property-name.json",
+      "punctuation.separator.key-value",
+      "punctuation.definition.template-expression"
+    ],
+    settings: {
+      foreground: "#000007"
+    }
+  },
+  {
+    scope: "variable.parameter.function",
+    settings: {
+      foreground: "#000008"
+    }
+  },
+  {
+    scope: [
+      "support.function",
+      "entity.name.type",
+      "entity.other.inherited-class",
+      "meta.function-call",
+      "meta.instance.constructor",
+      "entity.other.attribute-name",
+      "entity.name.function",
+      "constant.keyword.clojure"
+    ],
+    settings: {
+      foreground: "#000009"
+    }
+  },
+  {
+    scope: [
+      "entity.name.tag",
+      "string.quoted",
+      "string.regexp",
+      "string.interpolated",
+      "string.template",
+      "string.unquoted.plain.out.yaml",
+      "keyword.other.template"
+    ],
+    settings: {
+      foreground: "#000010"
+    }
+  },
+  {
+    scope: [
+      "punctuation.definition.arguments",
+      "punctuation.definition.dict",
+      "punctuation.separator",
+      "meta.function-call.arguments"
+    ],
+    settings: {
+      foreground: "#000011"
+    }
+  },
+  {
+    name: "[Custom] Markdown links",
+    scope: [
+      "markup.underline.link",
+      "punctuation.definition.metadata.markdown"
+    ],
+    settings: {
+      foreground: "#000012"
+    }
+  },
+  {
+    name: "[Custom] Markdown list",
+    scope: ["beginning.punctuation.definition.list.markdown"],
+    settings: {
+      foreground: "#000005"
+    }
+  },
+  {
+    name: "[Custom] Markdown punctuation definition brackets",
+    scope: [
+      "punctuation.definition.string.begin.markdown",
+      "punctuation.definition.string.end.markdown",
+      "string.other.link.title.markdown",
+      "string.other.link.description.markdown"
+    ],
+    settings: {
+      foreground: "#000007"
+    }
+  }
+];
+var theme_default = {
+  name,
+  type,
+  colors,
+  tokenColors
+};
+
+// src/compile.ts
+var createCompiler = (mdxOptions) => {
+  const compiler = createProcessor(mdxOptions);
+  compiler.data("headingMeta", {
+    headings: []
+  });
+  return compiler;
+};
+var rehypePrettyCodeOptions = {
+  theme: theme_default,
+  onVisitLine(node) {
+    if (node.children.length === 0) {
+      node.children = [{ type: "text", value: " " }];
+    }
+  },
+  onVisitHighlightedLine(node) {
+    node.properties.className.push("highlighted");
+  },
+  onVisitHighlightedWord(node) {
+    node.properties.className = ["highlighted"];
+  }
+};
+function compileMdx(_0) {
+  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {}, resourcePath = "") {
+    var _a;
+    const structurizedData = {};
+    const compiler = createCompiler({
+      jsx: (_a = mdxOptions.jsx) != null ? _a : true,
+      outputFormat: mdxOptions.outputFormat,
+      providerImportSource: "@mdx-js/react",
+      remarkPlugins: [
+        ...mdxOptions.remarkPlugins || [],
+        remarkGfm,
+        remarkHeadings,
+        ...nextraOptions.unstable_staticImage ? [remarkStaticImage] : [],
+        ...nextraOptions.unstable_flexsearch ? [structurize_default(structurizedData, nextraOptions.unstable_flexsearch)] : []
+      ].filter(Boolean),
+      rehypePlugins: [
+        ...mdxOptions.rehypePlugins || [],
+        parseMeta,
+        [rehypePrettyCode, rehypePrettyCodeOptions],
+        [rehypeMdxTitle, { name: "titleText" }],
+        attachMeta
+      ].filter(Boolean)
+    });
+    try {
+      const result = yield compiler.process(source);
+      return __spreadProps(__spreadValues({
+        result: String(result)
+      }, compiler.data("headingMeta")), {
+        structurizedData
+      });
+    } catch (err) {
+      console.error(`[nextra] Error compiling ${resourcePath}.`);
+      throw err;
+    }
+  });
+}
+export {
+  compileMdx
+};
diff --git a/node_modules/nextra/dist/constants.d.ts b/node_modules/nextra/dist/constants.d.ts
new file mode 100644
index 0000000..62c74d3
--- /dev/null
+++ b/node_modules/nextra/dist/constants.d.ts
@@ -0,0 +1,3 @@
+export declare const MARKDOWN_EXTENSION_REGEX: RegExp;
+export declare const IS_PRODUCTION: boolean;
+export declare const LOCALE_REGEX: RegExp;
diff --git a/node_modules/nextra/dist/content-dump.d.ts b/node_modules/nextra/dist/content-dump.d.ts
index 44028fa..77e6504 100644
--- a/node_modules/nextra/dist/content-dump.d.ts
+++ b/node_modules/nextra/dist/content-dump.d.ts
@@ -4,5 +4,5 @@ export declare function addPage({ fileLocale, route, title, data, structurizedDa
     title: string;
     data: any;
     structurizedData: any;
-}): Promise<void>;
+}): void;
 export declare function restoreCache(): Promise<void>;
diff --git a/node_modules/nextra/dist/index.js b/node_modules/nextra/dist/index.js
index d288128..72c2de2 100644
--- a/node_modules/nextra/dist/index.js
+++ b/node_modules/nextra/dist/index.js
@@ -56,73 +56,76 @@ var __async = (__this, __arguments, generator) => {
 
 // src/plugin.ts
 var import_graceful_fs2 = __toESM(require("graceful-fs"));
-var import_util = __toESM(require("util"));
+var import_util = require("util");
 
 // src/utils.ts
 var import_fs = __toESM(require("fs"));
-function getLocaleFromFilename(name) {
-  const localeRegex = /\.([a-zA-Z-]+)?\.(mdx?|jsx?|json)$/;
-  const match = name.match(localeRegex);
-  if (match)
-    return match[1];
-  return void 0;
-}
-function removeExtension(name) {
-  const match = name.match(/^([^.]+)/);
-  return match !== null ? match[1] : "";
+var import_path = __toESM(require("path"));
+
+// src/constants.ts
+var MARKDOWN_EXTENSION_REGEX = /\.mdx?$/;
+var IS_PRODUCTION = process.env.NODE_ENV === "production";
+var LOCALE_REGEX = /\.([a-z]{2}(-[A-Z]{2})?)$/;
+
+// src/utils.ts
+function parseFileName(filePath) {
+  var _a;
+  const { name, ext } = import_path.default.parse(filePath);
+  const locale = ((_a = name.match(LOCALE_REGEX)) == null ? void 0 : _a[1]) || "";
+  return {
+    name: locale ? name.replace(LOCALE_REGEX, "") : name,
+    locale,
+    ext
+  };
 }
-var parseJsonFile = (content, path4) => {
-  let parsed = {};
+var parseJsonFile = (content, path5) => {
   try {
-    parsed = JSON.parse(content);
+    return JSON.parse(content);
   } catch (err) {
-    console.error(`Error parsing ${path4}, make sure it's a valid JSON 
-` + err);
+    console.error(`[nextra] Error parsing ${path5}, make sure it's a valid JSON`, err);
+    return {};
   }
-  return parsed;
 };
-var existsSync = (f) => {
+var existsSync = (filePath) => {
   try {
-    import_fs.default.accessSync(f, import_fs.default.constants.F_OK);
+    import_fs.default.accessSync(filePath, import_fs.default.constants.F_OK);
     return true;
-  } catch (_) {
+  } catch (e) {
     return false;
   }
 };
 
 // src/plugin.ts
-var import_path3 = __toESM(require("path"));
+var import_path4 = __toESM(require("path"));
 var import_slash = __toESM(require("slash"));
 var import_gray_matter = __toESM(require("gray-matter"));
 
 // src/page-map.ts
-var import_path = __toESM(require("path"));
-var extension = /\.mdx?$/;
-var metaExtension = /meta\.?([a-zA-Z-]+)?\.json/;
+var import_path2 = __toESM(require("path"));
 function findPagesDir(dir = process.cwd()) {
-  if (existsSync(import_path.default.join(dir, "pages")))
+  if (existsSync(import_path2.default.join(dir, "pages")))
     return "pages";
-  if (existsSync(import_path.default.join(dir, "src/pages")))
+  if (existsSync(import_path2.default.join(dir, "src/pages")))
     return "src/pages";
   throw new Error("> Couldn't find a `pages` directory. Please create one under the project root");
 }
 
 // src/content-dump.ts
 var import_graceful_fs = __toESM(require("graceful-fs"));
-var import_path2 = __toESM(require("path"));
+var import_path3 = __toESM(require("path"));
 var { statSync, mkdirSync } = import_graceful_fs.default;
-var cacheDir = import_path2.default.join(process.cwd(), ".next", "cache");
-var assetDir = import_path2.default.join(process.cwd(), ".next", "static", "chunks");
+var cacheDir = import_path3.default.join(process.cwd(), ".next", "cache");
+var assetDir = import_path3.default.join(process.cwd(), ".next", "static", "chunks");
 try {
   statSync(assetDir);
-} catch (err) {
+} catch (e) {
   mkdirSync(assetDir, { recursive: true });
 }
 var cacheDirExist = false;
 try {
   statSync(cacheDir);
   cacheDirExist = true;
-} catch (err) {
+} catch (e) {
   mkdirSync(cacheDir, { recursive: true });
 }
 function restoreCache() {
@@ -130,13 +133,13 @@ function restoreCache() {
     if (cacheDirExist) {
       try {
         statSync(assetDir);
-      } catch (err) {
+      } catch (e) {
         mkdirSync(assetDir, { recursive: true });
       }
       const files = import_graceful_fs.default.readdirSync(cacheDir);
       for (const file of files) {
         if (file.startsWith("nextra-data-")) {
-          import_graceful_fs.default.copyFileSync(import_path2.default.join(cacheDir, file), import_path2.default.join(assetDir, file));
+          import_graceful_fs.default.copyFileSync(import_path3.default.join(cacheDir, file), import_path3.default.join(assetDir, file));
         }
       }
     }
@@ -144,54 +147,50 @@ function restoreCache() {
 }
 
 // src/plugin.ts
-var { readdir, readFile } = import_graceful_fs2.default;
+var readdir = (0, import_util.promisify)(import_graceful_fs2.default.readdir);
+var readFile = (0, import_util.promisify)(import_graceful_fs2.default.readFile);
+var collectFile = (filePath, fileMap, route = "") => __async(void 0, null, function* () {
+  const { name, locale, ext } = parseFileName(filePath);
+  if (MARKDOWN_EXTENSION_REGEX.test(ext)) {
+    const content = yield readFile(filePath, "utf8");
+    const { data } = (0, import_gray_matter.default)(content);
+    fileMap[filePath] = __spreadValues({
+      name,
+      route,
+      locale
+    }, Object.keys(data).length && { frontMatter: data });
+    return fileMap[filePath];
+  }
+  if (ext === ".json" && name === "meta") {
+    const content = yield readFile(filePath, "utf8");
+    fileMap[filePath] = {
+      name: "meta.json",
+      locale,
+      meta: parseJsonFile(content, filePath)
+    };
+    return fileMap[filePath];
+  }
+});
 function collectFiles(_0) {
   return __async(this, arguments, function* (dir, route = "/", fileMap = {}) {
-    const files = yield import_util.default.promisify(readdir)(dir, { withFileTypes: true });
+    const files = yield readdir(dir, { withFileTypes: true });
     const items = (yield Promise.all(files.map((f) => __async(this, null, function* () {
-      const filePath = import_path3.default.resolve(dir, f.name);
-      const fileRoute = (0, import_slash.default)(import_path3.default.join(route, removeExtension(f.name).replace(/^index$/, "")));
+      const filePath = import_path4.default.resolve(dir, f.name);
+      const { name } = parseFileName(filePath);
+      const fileRoute = (0, import_slash.default)(import_path4.default.join(route, name.replace(/^index$/, "")));
       if (f.isDirectory()) {
         if (fileRoute === "/api")
-          return null;
-        const { items: children } = yield collectFiles(filePath, fileRoute, fileMap);
-        if (!children || !children.length)
-          return null;
+          return;
+        const { items: items2 } = yield collectFiles(filePath, fileRoute, fileMap);
+        if (!items2.length)
+          return;
         return {
           name: f.name,
-          children,
+          children: items2,
           route: fileRoute
         };
-      } else if (extension.test(f.name)) {
-        const locale = getLocaleFromFilename(f.name);
-        const fileContents = yield import_util.default.promisify(readFile)(filePath, "utf-8");
-        const { data } = (0, import_gray_matter.default)(fileContents);
-        if (Object.keys(data).length) {
-          fileMap[filePath] = {
-            name: removeExtension(f.name),
-            route: fileRoute,
-            frontMatter: data,
-            locale
-          };
-          return fileMap[filePath];
-        }
-        fileMap[filePath] = {
-          name: removeExtension(f.name),
-          route: fileRoute,
-          locale
-        };
-        return fileMap[filePath];
-      } else if (metaExtension.test(f.name)) {
-        const content = yield import_util.default.promisify(readFile)(filePath, "utf-8");
-        const meta = parseJsonFile(content, filePath);
-        const locale = f.name.match(metaExtension)[1];
-        fileMap[filePath] = {
-          name: "meta.json",
-          meta,
-          locale
-        };
-        return fileMap[filePath];
       }
+      return collectFile(filePath, fileMap, fileRoute);
     })))).filter(Boolean);
     return {
       items,
@@ -216,15 +215,16 @@ var PageMapCache = class {
 };
 var pageMapCache = new PageMapCache();
 var NextraPlugin = class {
-  constructor(nextraConfig) {
-    this.config = nextraConfig;
+  constructor(config) {
+    this.config = config;
   }
   apply(compiler) {
     compiler.hooks.beforeCompile.tapAsync("NextraPlugin", (_, callback) => __async(this, null, function* () {
-      if (this.config && this.config.unstable_flexsearch) {
+      var _a;
+      if ((_a = this.config) == null ? void 0 : _a.unstable_flexsearch) {
         restoreCache();
       }
-      const result = yield collectFiles(import_path3.default.join(process.cwd(), findPagesDir()), "/");
+      const result = yield collectFiles(import_path4.default.join(process.cwd(), findPagesDir()), "/");
       pageMapCache.set(result);
       callback();
     }));
@@ -234,7 +234,6 @@ var NextraPlugin = class {
 // src/index.js
 var defaultExtensions = ["js", "jsx", "ts", "tsx"];
 var markdownExtensions = ["md", "mdx"];
-var markdownExtensionTest = /\.mdx?$/;
 module.exports = (...args) => (nextConfig = {}) => {
   var _a, _b;
   const nextraConfig = typeof args[0] === "string" ? {
@@ -246,11 +245,12 @@ module.exports = (...args) => (nextConfig = {}) => {
   let pageExtensions = nextConfig.pageExtensions || [...defaultExtensions];
   pageExtensions = pageExtensions.concat(markdownExtensions);
   if (locales) {
-    console.log("[Nextra] You have Next.js i18n enabled, read here (TODO: link) for the docs.");
+    console.log("[nextra] You have Next.js i18n enabled, read here (TODO: link) for the docs.");
   }
   return Object.assign({}, nextConfig, {
     pageExtensions,
     webpack(config, options) {
+      var _a2, _b2;
       const nextra = new NextraPlugin(nextraConfig);
       if (!config.plugins) {
         config.plugins = [nextra];
@@ -258,12 +258,17 @@ module.exports = (...args) => (nextConfig = {}) => {
         config.plugins.push(nextra);
       }
       config.module.rules.push({
-        test: markdownExtensionTest,
+        test: MARKDOWN_EXTENSION_REGEX,
         use: [
           options.defaultLoaders.babel,
           {
             loader: "nextra/loader",
-            options: __spreadProps(__spreadValues({}, nextraConfig), { locales, defaultLocale, pageMapCache })
+            options: __spreadProps(__spreadValues({}, nextraConfig), {
+              locales,
+              defaultLocale,
+              pageMapCache,
+              newNextLinkBehavior: (_b2 = (_a2 = nextConfig.experimental) == null ? void 0 : _a2.newNextLinkBehavior) != null ? _b2 : false
+            })
           }
         ]
       });
diff --git a/node_modules/nextra/dist/loader.mjs b/node_modules/nextra/dist/loader.mjs
index 486c1fb..c20209a 100644
--- a/node_modules/nextra/dist/loader.mjs
+++ b/node_modules/nextra/dist/loader.mjs
@@ -39,7 +39,7 @@ var __async = (__this, __arguments, generator) => {
 };
 
 // src/loader.ts
-import path4 from "path";
+import path5 from "path";
 import grayMatter2 from "gray-matter";
 import slash2 from "slash";
 import { Repository } from "@napi-rs/simple-git";
@@ -54,14 +54,14 @@ var asset = {};
 var cached = /* @__PURE__ */ new Map();
 try {
   statSync(assetDir);
-} catch (err) {
+} catch (e) {
   mkdirSync(assetDir, { recursive: true });
 }
 var cacheDirExist = false;
 try {
   statSync(cacheDir);
   cacheDirExist = true;
-} catch (err) {
+} catch (e) {
   mkdirSync(cacheDir, { recursive: true });
 }
 function initFromCache(filename) {
@@ -76,56 +76,57 @@ function initFromCache(filename) {
   }
   return {};
 }
-function addPage(_0) {
-  return __async(this, arguments, function* ({
-    fileLocale,
-    route,
-    title,
-    data,
-    structurizedData
-  }) {
-    const dataFilename = `nextra-data-${fileLocale}.json`;
-    if (!asset[fileLocale]) {
-      asset[fileLocale] = initFromCache(dataFilename);
-    }
-    asset[fileLocale][route] = {
-      title: title || data.title,
-      data: structurizedData
-    };
-    const content = JSON.stringify(asset[fileLocale]);
-    fs.writeFileSync(path.join(assetDir, dataFilename), content);
-    fs.writeFileSync(path.join(cacheDir, dataFilename), content);
-  });
+function addPage({
+  fileLocale,
+  route,
+  title,
+  data,
+  structurizedData
+}) {
+  const dataFilename = `nextra-data-${fileLocale}.json`;
+  asset[fileLocale] || (asset[fileLocale] = initFromCache(dataFilename));
+  asset[fileLocale][route] = {
+    title: title || data.title,
+    data: structurizedData
+  };
+  const content = JSON.stringify(asset[fileLocale]);
+  fs.writeFileSync(path.join(assetDir, dataFilename), content);
+  fs.writeFileSync(path.join(cacheDir, dataFilename), content);
 }
 
 // src/utils.ts
 import fs2 from "fs";
-function getLocaleFromFilename(name2) {
-  const localeRegex = /\.([a-zA-Z-]+)?\.(mdx?|jsx?|json)$/;
-  const match = name2.match(localeRegex);
-  if (match)
-    return match[1];
-  return void 0;
-}
-function removeExtension(name2) {
-  const match = name2.match(/^([^.]+)/);
-  return match !== null ? match[1] : "";
+import path2 from "path";
+
+// src/constants.ts
+var MARKDOWN_EXTENSION_REGEX = /\.mdx?$/;
+var IS_PRODUCTION = process.env.NODE_ENV === "production";
+var LOCALE_REGEX = /\.([a-z]{2}(-[A-Z]{2})?)$/;
+
+// src/utils.ts
+function parseFileName(filePath) {
+  var _a;
+  const { name: name2, ext } = path2.parse(filePath);
+  const locale = ((_a = name2.match(LOCALE_REGEX)) == null ? void 0 : _a[1]) || "";
+  return {
+    name: locale ? name2.replace(LOCALE_REGEX, "") : name2,
+    locale,
+    ext
+  };
 }
-var parseJsonFile = (content, path5) => {
-  let parsed = {};
+var parseJsonFile = (content, path6) => {
   try {
-    parsed = JSON.parse(content);
+    return JSON.parse(content);
   } catch (err) {
-    console.error(`Error parsing ${path5}, make sure it's a valid JSON 
-` + err);
+    console.error(`[nextra] Error parsing ${path6}, make sure it's a valid JSON`, err);
+    return {};
   }
-  return parsed;
 };
-var existsSync = (f) => {
+var existsSync = (filePath) => {
   try {
-    fs2.accessSync(f, fs2.constants.F_OK);
+    fs2.accessSync(filePath, fs2.constants.F_OK);
     return true;
-  } catch (_) {
+  } catch (e) {
     return false;
   }
 };
@@ -134,6 +135,7 @@ var existsSync = (f) => {
 import { createProcessor } from "@mdx-js/mdx";
 import remarkGfm from "remark-gfm";
 import rehypePrettyCode from "rehype-pretty-code";
+import { rehypeMdxTitle } from "rehype-mdx-title";
 
 // src/mdx-plugins/static-image.js
 var relative = /^\.{1,2}\//;
@@ -252,17 +254,7 @@ function remarkHeadings() {
         const heading = __spreadProps(__spreadValues({}, node), {
           value: getFlattenedValue(node)
         });
-        const headingMeta = data.headingMeta;
-        if (node.depth === 1) {
-          headingMeta.hasH1 = true;
-          if (Array.isArray(node.children) && node.children.length === 1) {
-            const child = node.children[0];
-            if (child.type === "text") {
-              headingMeta.titleText = child.value;
-            }
-          }
-        }
-        headingMeta.headings.push(heading);
+        data.headingMeta.headings.push(heading);
       } else if (node.name === "summary" || node.name === "details") {
         if (node.data) {
           delete node.data._mdxExplicitJsx;
@@ -594,34 +586,31 @@ var theme_default = {
 var createCompiler = (mdxOptions) => {
   const compiler = createProcessor(mdxOptions);
   compiler.data("headingMeta", {
-    hasH1: false,
     headings: []
   });
   return compiler;
 };
 var rehypePrettyCodeOptions = {
   theme: theme_default,
-  onVisitHighlightedLine(node) {
-    if (!node.properties.className) {
-      node.properties.className = [];
+  onVisitLine(node) {
+    if (node.children.length === 0) {
+      node.children = [{ type: "text", value: " " }];
     }
+  },
+  onVisitHighlightedLine(node) {
     node.properties.className.push("highlighted");
   },
   onVisitHighlightedWord(node) {
-    if (!node.properties.className) {
-      node.properties.className = [];
-    }
-    node.properties.className.push("highlighted");
+    node.properties.className = ["highlighted"];
   }
 };
 function compileMdx(_0) {
-  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {
-    unstable_staticImage: false,
-    unstable_flexsearch: false
-  }, resourcePath) {
-    let structurizedData = {};
+  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {}, resourcePath = "") {
+    var _a;
+    const structurizedData = {};
     const compiler = createCompiler({
-      jsx: true,
+      jsx: (_a = mdxOptions.jsx) != null ? _a : true,
+      outputFormat: mdxOptions.outputFormat,
       providerImportSource: "@mdx-js/react",
       remarkPlugins: [
         ...mdxOptions.remarkPlugins || [],
@@ -634,6 +623,7 @@ function compileMdx(_0) {
         ...mdxOptions.rehypePlugins || [],
         parseMeta,
         [rehypePrettyCode, rehypePrettyCodeOptions],
+        [rehypeMdxTitle, { name: "titleText" }],
         attachMeta
       ].filter(Boolean)
     });
@@ -645,17 +635,14 @@ function compileMdx(_0) {
         structurizedData
       });
     } catch (err) {
-      console.error(`
-Error compiling ${resourcePath}`);
-      console.error(`${err}
-`);
+      console.error(`[nextra] Error compiling ${resourcePath}.`);
       throw err;
     }
   });
 }
 
 // src/page-map.ts
-import path2 from "path";
+import path3 from "path";
 
 // src/filter-route-locale.ts
 function filterRouteLocale(pageMap, locale, defaultLocale) {
@@ -688,87 +675,78 @@ function filterRouteLocale(pageMap, locale, defaultLocale) {
 }
 
 // src/page-map.ts
-var extension = /\.mdx?$/;
-var metaExtension = /meta\.?([a-zA-Z-]+)?\.json/;
 function findPagesDir(dir = process.cwd()) {
-  if (existsSync(path2.join(dir, "pages")))
+  if (existsSync(path3.join(dir, "pages")))
     return "pages";
-  if (existsSync(path2.join(dir, "src/pages")))
+  if (existsSync(path3.join(dir, "src/pages")))
     return "src/pages";
   throw new Error("> Couldn't find a `pages` directory. Please create one under the project root");
 }
-function getPageMap(currentResourcePath, pageMaps, fileMap, defaultLocale) {
+function getPageMap(currentResourcePath, pageMap, fileMap, defaultLocale) {
   var _a, _b;
-  const activeRouteLocale = getLocaleFromFilename(currentResourcePath);
+  const activeRouteLocale = parseFileName(currentResourcePath).locale;
   const pageItem = fileMap[currentResourcePath];
-  const metaPath = path2.dirname(currentResourcePath);
-  const metaExtension2 = activeRouteLocale ? `${activeRouteLocale}.json` : `json`;
-  const pageMeta = (_b = (_a = fileMap[`${metaPath}/meta.${metaExtension2}`]) == null ? void 0 : _a.meta) == null ? void 0 : _b[pageItem.name];
+  const metaPath = path3.dirname(currentResourcePath);
+  const metaExtension = activeRouteLocale ? `${activeRouteLocale}.json` : `json`;
+  const pageMeta = (_b = (_a = fileMap[`${metaPath}/meta.${metaExtension}`]) == null ? void 0 : _a.meta) == null ? void 0 : _b[pageItem.name];
   const title = (typeof pageMeta === "string" ? pageMeta : pageMeta == null ? void 0 : pageMeta.title) || pageItem.name;
-  if (activeRouteLocale) {
-    return [
-      filterRouteLocale(pageMaps, activeRouteLocale, defaultLocale),
-      fileMap[currentResourcePath].route,
-      title
-    ];
-  }
-  return [pageMaps, fileMap[currentResourcePath].route, title];
+  return [
+    activeRouteLocale ? filterRouteLocale(pageMap, activeRouteLocale, defaultLocale) : pageMap,
+    pageItem.route,
+    title
+  ];
 }
 
 // src/plugin.ts
 import fs3 from "graceful-fs";
-import util from "util";
-import path3 from "path";
+import { promisify } from "util";
+import path4 from "path";
 import slash from "slash";
 import grayMatter from "gray-matter";
-var { readdir, readFile } = fs3;
+var readdir = promisify(fs3.readdir);
+var readFile = promisify(fs3.readFile);
+var collectFile = (filePath, fileMap, route = "") => __async(void 0, null, function* () {
+  const { name: name2, locale, ext } = parseFileName(filePath);
+  if (MARKDOWN_EXTENSION_REGEX.test(ext)) {
+    const content = yield readFile(filePath, "utf8");
+    const { data } = grayMatter(content);
+    fileMap[filePath] = __spreadValues({
+      name: name2,
+      route,
+      locale
+    }, Object.keys(data).length && { frontMatter: data });
+    return fileMap[filePath];
+  }
+  if (ext === ".json" && name2 === "meta") {
+    const content = yield readFile(filePath, "utf8");
+    fileMap[filePath] = {
+      name: "meta.json",
+      locale,
+      meta: parseJsonFile(content, filePath)
+    };
+    return fileMap[filePath];
+  }
+});
 function collectFiles(_0) {
   return __async(this, arguments, function* (dir, route = "/", fileMap = {}) {
-    const files = yield util.promisify(readdir)(dir, { withFileTypes: true });
+    const files = yield readdir(dir, { withFileTypes: true });
     const items = (yield Promise.all(files.map((f) => __async(this, null, function* () {
-      const filePath = path3.resolve(dir, f.name);
-      const fileRoute = slash(path3.join(route, removeExtension(f.name).replace(/^index$/, "")));
+      const filePath = path4.resolve(dir, f.name);
+      const { name: name2 } = parseFileName(filePath);
+      const fileRoute = slash(path4.join(route, name2.replace(/^index$/, "")));
       if (f.isDirectory()) {
         if (fileRoute === "/api")
-          return null;
-        const { items: children } = yield collectFiles(filePath, fileRoute, fileMap);
-        if (!children || !children.length)
-          return null;
+          return;
+        const { items: items2 } = yield collectFiles(filePath, fileRoute, fileMap);
+        if (!items2.length)
+          return;
         return {
           name: f.name,
-          children,
+          children: items2,
           route: fileRoute
         };
-      } else if (extension.test(f.name)) {
-        const locale = getLocaleFromFilename(f.name);
-        const fileContents = yield util.promisify(readFile)(filePath, "utf-8");
-        const { data } = grayMatter(fileContents);
-        if (Object.keys(data).length) {
-          fileMap[filePath] = {
-            name: removeExtension(f.name),
-            route: fileRoute,
-            frontMatter: data,
-            locale
-          };
-          return fileMap[filePath];
-        }
-        fileMap[filePath] = {
-          name: removeExtension(f.name),
-          route: fileRoute,
-          locale
-        };
-        return fileMap[filePath];
-      } else if (metaExtension.test(f.name)) {
-        const content = yield util.promisify(readFile)(filePath, "utf-8");
-        const meta = parseJsonFile(content, filePath);
-        const locale = f.name.match(metaExtension)[1];
-        fileMap[filePath] = {
-          name: "meta.json",
-          meta,
-          locale
-        };
-        return fileMap[filePath];
       }
+      return collectFile(filePath, fileMap, fileRoute);
     })))).filter(Boolean);
     return {
       items,
@@ -794,17 +772,15 @@ var PageMapCache = class {
 var pageMapCache = new PageMapCache();
 
 // src/loader.ts
-var extension2 = /\.mdx?$/;
-var isProductionBuild = process.env.NODE_ENV === "production";
 var indexContentEmitted = /* @__PURE__ */ new Set();
-var pagesDir = path4.resolve(findPagesDir());
+var pagesDir = path5.resolve(findPagesDir());
 var [repository, gitRoot] = function() {
   try {
     const repo = Repository.discover(process.cwd());
-    const gitRoot2 = path4.join(repo.path(), "..");
+    const gitRoot2 = path5.join(repo.path(), "..");
     return [repo, gitRoot2];
   } catch (e) {
-    console.warn("Init git repository failed", e);
+    console.warn("[nextra] Init git repository failed", e);
     return [];
   }
 }();
@@ -822,23 +798,22 @@ function loader(context, source) {
       pageMapCache: pageMapCache2
     } = options;
     const { resourcePath } = context;
-    const filename = resourcePath.slice(resourcePath.lastIndexOf("/") + 1);
-    const fileLocale = getLocaleFromFilename(filename);
+    if (resourcePath.includes("/pages/api/")) {
+      console.warn(`[nextra] Ignoring ${resourcePath} because it is located in the "pages/api" folder.`);
+      return "";
+    }
+    const filename = path5.basename(resourcePath);
+    const fileLocale = parseFileName(filename).locale;
     if (!theme) {
       throw new Error("No Nextra theme found!");
     }
-    let pageMapResult, fileMap;
-    if (isProductionBuild) {
-      const data2 = pageMapCache2.get();
-      pageMapResult = data2.items;
-      fileMap = data2.fileMap;
-    } else {
-      const data2 = yield collectFiles(pagesDir, "/");
-      pageMapResult = data2.items;
-      fileMap = data2.fileMap;
+    const { items: pageMapResult, fileMap } = IS_PRODUCTION ? pageMapCache2.get() : yield collectFiles(pagesDir, "/");
+    if (!fileMap[resourcePath]) {
+      yield collectFile(resourcePath, fileMap);
+      context.addMissingDependency(resourcePath);
     }
     const [pageMap, route, title] = getPageMap(resourcePath, pageMapResult, fileMap, defaultLocale);
-    if (!isProductionBuild) {
+    if (!IS_PRODUCTION) {
       context.addContextDependency(pagesDir);
     } else {
       Object.entries(fileMap).forEach(([filePath, { name: name2, meta, locale }]) => {
@@ -847,27 +822,25 @@ function loader(context, source) {
         }
       });
     }
-    let { data, content } = grayMatter2(source);
+    const { data, content } = grayMatter2(source);
     let layout = theme;
     let layoutConfig = themeConfig || null;
     if (theme.startsWith(".") || theme.startsWith("/")) {
-      layout = path4.resolve(theme);
+      layout = path5.resolve(theme);
     }
     if (layoutConfig) {
-      layoutConfig = slash2(path4.resolve(layoutConfig));
+      layoutConfig = slash2(path5.resolve(layoutConfig));
     }
-    if (isProductionBuild && indexContentEmitted.has(filename)) {
+    if (IS_PRODUCTION && indexContentEmitted.has(filename)) {
       unstable_flexsearch = false;
     }
-    const { result, titleText, headings, hasH1, structurizedData } = yield compileMdx(content, mdxOptions, {
+    const { result, headings, structurizedData } = yield compileMdx(content, mdxOptions, {
       unstable_staticImage,
       unstable_flexsearch
     }, resourcePath);
-    content = result;
-    content = content.replace("export default MDXContent;", "");
     if (unstable_flexsearch) {
-      if (extension2.test(filename) && data.searchable !== false) {
-        yield addPage({
+      if (MARKDOWN_EXTENSION_REGEX.test(filename) && data.searchable !== false) {
+        addPage({
           fileLocale: fileLocale || "default",
           route,
           title,
@@ -881,46 +854,57 @@ function loader(context, source) {
     if (repository && gitRoot) {
       if (repository.isShallow()) {
         if (process.env.VERCEL) {
-          console.warn(`The repository is shallow cloned, so the latest modified time will not be presented. Set the VERCEL_DEEP_CLONE=true environment variable to enable deep cloning.`);
+          console.warn("[nextra] The repository is shallow cloned, so the latest modified time will not be presented. Set the VERCEL_DEEP_CLONE=true environment variable to enable deep cloning.");
         } else if (process.env.GITHUB_ACTION) {
-          console.warn(`The repository is shallow cloned, so the latest modified time will not be presented. See https://github.com/actions/checkout#fetch-all-history-for-all-tags-and-branches to fetch all the history.`);
+          console.warn("[nextra] The repository is shallow cloned, so the latest modified time will not be presented. See https://github.com/actions/checkout#fetch-all-history-for-all-tags-and-branches to fetch all the history.");
         } else {
-          console.warn(`The repository is shallow cloned, so the latest modified time will not be presented.`);
+          console.warn("[nextra] The repository is shallow cloned, so the latest modified time will not be presented.");
         }
       }
       try {
-        timestamp = yield repository.getFileLatestModifiedDateAsync(path4.relative(gitRoot, resourcePath));
+        timestamp = yield repository.getFileLatestModifiedDateAsync(path5.relative(gitRoot, resourcePath));
       } catch (e) {
       }
     }
-    const prefix = `import __nextra_withLayout__ from '${layout}'
+    const loaderOptions = JSON.stringify({
+      newNextLinkBehavior: options.newNextLinkBehavior
+    });
+    const layoutConfigImport = layoutConfig ? `import __nextra_layoutConfig__ from '${layoutConfig}'` : "";
+    return `
+import __nextra_withLayout__ from '${layout}'
 import { withSSG as __nextra_withSSG__ } from 'nextra/ssg'
-${layoutConfig ? `import __nextra_layoutConfig__ from '${layoutConfig}'` : ""}
+${layoutConfigImport}
+${result.replace("export default MDXContent;", "")}
 
 const __nextra_pageMap__ = ${JSON.stringify(pageMap)}
+
 globalThis.__nextra_internal__ = {
   pageMap: __nextra_pageMap__,
-  route: ${JSON.stringify(route)},
+  route: ${JSON.stringify(route)}
 }
 
-    const __nextra_content__ = <MDXContent/>
-    const NextraLayout = __nextra_withSSG__(__nextra_withLayout__({
-      filename: "${slash2(filename)}",
-      route: "${slash2(route)}",
-      meta: ${JSON.stringify(data)},
-      pageMap: __nextra_pageMap__,
-      titleText: ${JSON.stringify(titleText)},
-      headings: ${JSON.stringify(headings)},
-      hasH1: ${JSON.stringify(hasH1)},
-      ${timestamp ? `timestamp: ${timestamp},
+const NextraLayout = __nextra_withSSG__(__nextra_withLayout__({
+  filename: "${slash2(filename)}",
+  route: "${slash2(route)}",
+  meta: ${JSON.stringify(data)},
+  pageMap: __nextra_pageMap__,
+  titleText: typeof titleText === 'string' ? titleText : undefined,
+  headings: ${JSON.stringify(headings)},
+  ${timestamp ? `timestamp: ${timestamp},
 ` : ""}
-    }, ${layoutConfig ? "__nextra_layoutConfig__" : "null"}))
-    `;
-    const suffix = `export default function NextraPage (props) {
-  return <NextraLayout {...props}>{__nextra_content__}</NextraLayout>
+}, ${layoutConfig ? `{...__nextra_layoutConfig__,...${loaderOptions}}` : loaderOptions}))
+
+function NextraPage(props) {
+  return (
+    <NextraLayout {...props}>
+      <MDXContent />
+    </NextraLayout>
+  )
 }
-NextraPage.getLayout = NextraLayout.getLayout`;
-    return prefix + "\n\n" + content + "\n\n" + suffix;
+NextraPage.getLayout = NextraLayout.getLayout
+
+export default NextraPage
+`.trimStart();
   });
 }
 function syncLoader(source, callback) {
diff --git a/node_modules/nextra/dist/locales.js b/node_modules/nextra/dist/locales.js
index 85a453d..3b6c915 100644
--- a/node_modules/nextra/dist/locales.js
+++ b/node_modules/nextra/dist/locales.js
@@ -28,10 +28,9 @@ __export(locales_exports, {
   withLocales: () => withLocales
 });
 var import_server = require("next/server");
-var PUBLIC_FILE = /\.(.*)$/;
 function locales(request) {
   const { nextUrl } = request;
-  const shouldHandleLocale = !PUBLIC_FILE.test(nextUrl.pathname) && !nextUrl.pathname.includes("/api/") && !nextUrl.pathname.includes("/_next/") && nextUrl.locale !== "";
+  const shouldHandleLocale = !/^\/(api|_next)\//.test(nextUrl.pathname) && !/\.(jpe?g|svg|png|webmanifest)$/.test(nextUrl.pathname) && nextUrl.locale !== "";
   if (!shouldHandleLocale)
     return;
   const fullUrl = nextUrl.toString();
diff --git a/node_modules/nextra/dist/page-map.d.ts b/node_modules/nextra/dist/page-map.d.ts
index 613c963..a271721 100644
--- a/node_modules/nextra/dist/page-map.d.ts
+++ b/node_modules/nextra/dist/page-map.d.ts
@@ -1,5 +1,3 @@
 import { PageMapItem } from './types';
-export declare const extension: RegExp;
-export declare const metaExtension: RegExp;
 export declare function findPagesDir(dir?: string): string;
-export declare function getPageMap(currentResourcePath: string, pageMaps: PageMapItem[], fileMap: Record<string, PageMapItem>, defaultLocale: string): any[];
+export declare function getPageMap(currentResourcePath: string, pageMap: PageMapItem[], fileMap: Record<string, PageMapItem>, defaultLocale: string): [PageMapItem[], string, string];
diff --git a/node_modules/nextra/dist/plugin.d.ts b/node_modules/nextra/dist/plugin.d.ts
index ae1d17f..8364f01 100644
--- a/node_modules/nextra/dist/plugin.d.ts
+++ b/node_modules/nextra/dist/plugin.d.ts
@@ -1,5 +1,6 @@
-import { PageMapItem } from './types';
+import { NextraConfig, PageMapItem } from './types';
 import { Compiler } from 'webpack';
+export declare const collectFile: (filePath: string, fileMap: Record<string, any>, route?: string) => Promise<any>;
 export declare function collectFiles(dir: string, route?: string, fileMap?: Record<string, any>): Promise<{
     items: PageMapItem[];
     fileMap: Record<string, any>;
@@ -21,9 +22,8 @@ export declare class PageMapCache {
     } | null;
 }
 export declare const pageMapCache: PageMapCache;
-declare class NextraPlugin {
-    config: any;
-    constructor(nextraConfig: any);
+export declare class NextraPlugin {
+    private config;
+    constructor(config: NextraConfig);
     apply(compiler: Compiler): void;
 }
-export { NextraPlugin };
diff --git a/node_modules/nextra/dist/types.d.ts b/node_modules/nextra/dist/types.d.ts
index 9a63bef..189f9bc 100644
--- a/node_modules/nextra/dist/types.d.ts
+++ b/node_modules/nextra/dist/types.d.ts
@@ -1,15 +1,12 @@
 import { Heading as MDASTHeading } from 'mdast';
 import { ProcessorOptions } from '@mdx-js/mdx';
 import { PageMapCache } from './plugin';
-export interface LoaderOptions {
-    theme: Theme;
-    themeConfig: string;
+export interface LoaderOptions extends NextraConfig {
     locales: string[];
     defaultLocale: string;
-    unstable_staticImage: boolean;
-    unstable_flexsearch: boolean;
     mdxOptions: Pick<ProcessorOptions, 'rehypePlugins' | 'remarkPlugins'>;
     pageMapCache: PageMapCache;
+    newNextLinkBehavior: boolean;
 }
 export interface PageMapItem {
     name: string;
@@ -31,7 +28,6 @@ export interface PageOpt {
     pageMap: PageMapItem[];
     titleText: string | null;
     headings?: Heading[];
-    hasH1: boolean;
 }
 export declare type PageMapResult = [
     pageMap: PageMapItem[],
diff --git a/node_modules/nextra/dist/utils.d.ts b/node_modules/nextra/dist/utils.d.ts
index adf3d93..39d4927 100644
--- a/node_modules/nextra/dist/utils.d.ts
+++ b/node_modules/nextra/dist/utils.d.ts
@@ -1,5 +1,7 @@
-export declare function getLocaleFromFilename(name: string): string | undefined;
-export declare function removeExtension(name: string): string;
-export declare function getFileName(resourcePath: string): string;
+export declare function parseFileName(filePath: string): {
+    name: string;
+    locale: string;
+    ext: string;
+};
 export declare const parseJsonFile: (content: string, path: string) => Record<string, any>;
-export declare const existsSync: (f: string) => boolean;
+export declare const existsSync: (filePath: string) => boolean;
diff --git a/node_modules/nextra/index.js b/node_modules/nextra/index.js
deleted file mode 100755
index aae5903..0000000
--- a/node_modules/nextra/index.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/index')
diff --git a/node_modules/nextra/loader.js b/node_modules/nextra/loader.js
index b7d9ded..5283c07 100755
--- a/node_modules/nextra/loader.js
+++ b/node_modules/nextra/loader.js
@@ -10,7 +10,7 @@
 module.exports = function (code) {
   const callback = this.async()
   // Note that `import()` caches, so this should be fast enough.
-  import('./dist/loader.mjs').then(module =>
-    module.default.call(this, code, callback)
+  import('./dist/loader.mjs').then(mod =>
+    mod.default.call(this, code, callback)
   )
 }
diff --git a/node_modules/nextra/locales.js b/node_modules/nextra/locales.js
deleted file mode 100644
index 0adc2a7..0000000
--- a/node_modules/nextra/locales.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/locales')
diff --git a/node_modules/nextra/package.json b/node_modules/nextra/package.json
index 47e2096..c7e64f1 100644
--- a/node_modules/nextra/package.json
+++ b/node_modules/nextra/package.json
@@ -5,19 +5,23 @@
   "main": "index.js",
   "files": [
     "dist/*",
-    "index.js",
-    "ssg.js",
-    "data.js",
-    "loader.js",
-    "locales.js",
-    "context.js"
+    "loader.js"
   ],
+  "exports": {
+    ".": "./dist/index.js",
+    "./compile": "./dist/compile.mjs",
+    "./context": "./dist/context.js",
+    "./data": "./dist/ssg.js",
+    "./loader": "./loader.js",
+    "./locales": "./dist/locales.js",
+    "./ssg": "./dist/ssg.js"
+  },
   "types": "./dist/types.d.ts",
   "repository": "https://github.com/shuding/nextra",
   "license": "MIT",
   "scripts": {
     "build": "node scripts/build.js",
-    "dev": "node scripts/dev.js",
+    "dev": "node scripts/build.js --dev",
     "types": "tsc --project tsconfig.type.json",
     "test": "vitest run",
     "prepublishOnly": "rm -rf dist && pnpm build && pnpm types"
@@ -28,7 +32,7 @@
     "github-slugger": "^1.4.0",
     "graceful-fs": "^4.2.6",
     "gray-matter": "^4.0.3",
-    "p-limit": "^4.0.0",
+    "rehype-mdx-title": "^1.0.0",
     "rehype-pretty-code": "^0.1.0",
     "remark-gfm": "^3.0.1",
     "shiki": "0.10.1",
diff --git a/node_modules/nextra/ssg.js b/node_modules/nextra/ssg.js
deleted file mode 100755
index 9016f08..0000000
--- a/node_modules/nextra/ssg.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/ssg')